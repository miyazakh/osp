diff --git a/examples/network/network.pro b/examples/network/network.pro
index 3f851d7c71..484c782453 100644
--- a/examples/network/network.pro
+++ b/examples/network/network.pro
@@ -26,6 +26,7 @@ qtHaveModule(widgets) {
             fortuneserver
 
     qtConfig(ssl): SUBDIRS += securesocketclient
+    qtConfig(wolfssl): SUBDIRS += securesocketclient
     qtConfig(dtls): SUBDIRS += secureudpserver secureudpclient
     qtConfig(sctp): SUBDIRS += multistreamserver multistreamclient
 }
diff --git a/src/network/configure.json b/src/network/configure.json
index 271ff164ac..3073ca718e 100644
--- a/src/network/configure.json
+++ b/src/network/configure.json
@@ -7,13 +7,17 @@
 
     "commandline": {
         "assignments": {
-            "OPENSSL_PATH": "openssl.prefix"
+            "OPENSSL_PATH": "openssl.prefix",
+            "WOLFSSL_PATH": "wolfssl.prefix"
         },
         "options": {
             "libproxy": "boolean",
             "openssl": { "type": "optionalString", "values": [ "no", "yes", "linked", "runtime" ] },
             "openssl-linked": { "type": "void", "name": "openssl", "value": "linked" },
             "openssl-runtime": { "type": "void", "name": "openssl", "value": "runtime" },
+            "wolfssl": { "type": "optionalString", "values": [ "no", "yes", "linked", "runtime" ] },
+            "wolfssl-linked": { "type": "void", "name": "wolfssl", "value": "linked" },
+            "wolfssl-runtime": { "type": "void", "name": "wolfssl", "value": "runtime" },
             "dtls": "boolean",
             "ocsp": "boolean",
             "sctp": "boolean",
@@ -103,6 +107,37 @@
                 }
             ]
         },
+        "wolfssl_headers": {
+            "label": "wolfSSL Headers with OpenSSL Compatibility",
+            "export": "wolfssl",
+            "test": {
+                "tail": [
+                    "#if !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER-0 < 0x10001000L",
+                    "#  error wolfSSL OPENSSL_VERSION_NUMBER >= 0x10001000L is required",
+                    "#endif"
+                ]
+            },
+            "headers": [ "wolfssl/options.h", "wolfssl/ssl.h" ],
+            "sources": [
+                {
+                    "comment": "placeholder for OPENSSL_PATH",
+                    "libs": ""
+                }
+            ]
+        },
+        "wolfssl": {
+            "label": "wolfSSL with OpenSSL Compatibility",
+            "test": {
+                "inherit": "wolfssl_headers",
+                "main": "SSL_free(SSL_new(0));"
+            },
+            "sources": [
+                { "type": "wolfssl" },
+                {
+                    "libs": "-lwolfssl"
+                }
+            ]
+        },
         "gssapi": {
             "label": "KRB5 GSSAPI Support",
             "test": {
@@ -268,7 +303,8 @@
             "output": [
                 "privateFeature",
                 { "type": "publicQtConfig", "condition": "!features.openssl-linked" },
-                { "type": "define", "negative": true, "name": "QT_NO_OPENSSL" }
+                { "type": "define", "negative": true, "condition": "!features.openssl && !features.wolfssl", "name": "QT_NO_OPENSSL" }
+
             ]
         },
         "openssl-runtime": {
@@ -287,10 +323,37 @@
                 { "type": "define", "name": "QT_LINKED_OPENSSL" }
             ]
         },
+        "wolfssl": {
+            "label": "wolfSSL",
+            "enable": "false",
+            "condition": "features.wolfssl-runtime || features.wolfssl-linked",
+            "output": [
+                "privateFeature",
+                { "type": "publicQtConfig", "condition": "!features.wolfssl-linked" },
+                { "type": "define", "negative": true, "name": "QT_NO_WOLFSSL" }
+            ]
+        },
+        "wolfssl-runtime": {
+            "autoDetect": "!config.winrt && !config.wasm",
+            "enable": "input.wolfssl == 'yes' || input.wolfssl == 'runtime'",
+            "disable": "input.wolfssl == 'no' || input.wolfssl == 'linked' || input.ssl == 'no'",
+            "condition": "!features.securetransport && libs.wolfssl_headers"
+        },
+        "wolfssl-linked": {
+            "label": "  Qt directly linked to wolfSSL",
+            "autoDetect": false,
+            "enable": "input.wolfssl == 'linked'",
+            "condition": "!features.securetransport && libs.wolfssl",
+            "output": [
+                "privateFeature",
+                { "type": "define", "name": "QT_LINKED_WOLFSSL" },
+                { "type": "define", "name": "QT_LINKED_OPENSSL" }
+            ]
+        },
         "securetransport": {
             "label": "SecureTransport",
             "disable": "input.securetransport == 'no' || input.ssl == 'no'",
-            "condition": "config.darwin && (input.openssl == '' || input.openssl == 'no')",
+            "condition": "config.darwin && (input.openssl == '' || input.openssl == 'no') && (input.wolfssl == '' || input.wolfssl == 'no')",
             "output": [
                 "publicFeature",
                 { "type": "define", "name": "QT_SECURETRANSPORT" }
@@ -307,14 +370,14 @@
         },
         "ssl": {
             "label": "SSL",
-            "condition": "config.winrt || features.securetransport || features.openssl || features.schannel",
+            "condition": "config.winrt || features.securetransport || features.openssl || features.schannel || features.wolfssl",
             "output": [ "publicFeature", "feature" ]
         },
         "dtls": {
             "label": "DTLS",
             "purpose": "Provides a DTLS implementation",
             "section": "Networking",
-            "condition": "features.openssl && features.udpsocket && tests.dtls",
+            "condition": "features.openssl && features.udpsocket && !features.wolfssl && tests.dtls",
             "output": [ "publicFeature" ]
         },
         "ocsp": {
@@ -326,7 +389,7 @@
         },
         "opensslv11": {
             "label": "OpenSSL 1.1",
-            "condition": "features.openssl",
+            "condition": "features.openssl && !features.wolfssl",
             "output": [ "publicFeature" ]
         },
         "sctp": {
diff --git a/src/network/configure.pri b/src/network/configure.pri
index ad4d711cba..d1e54014e4 100644
--- a/src/network/configure.pri
+++ b/src/network/configure.pri
@@ -10,4 +10,13 @@ defineTest(qtConfLibrary_openssl) {
     qtLog("$OPENSSL_LIBS is not set.")
     return(false)
 }
-
+defineTest(qtConfLibrary_wolfssl) {
+    eval(libs = $$getenv("WOLFSSL_LIBS"))
+    !isEmpty(libs) {
+        !qtConfResolveLibs($${1}.libs, $$libs): \
+            return(false)
+        return(true)
+    }
+    qtLog("$WOLFSSL_LIBS is not set.")
+    return(false)
+}
diff --git a/src/network/ssl/qsslcertificate_openssl.cpp b/src/network/ssl/qsslcertificate_openssl.cpp
index ca9d61ccb1..8b6b99c1ed 100644
--- a/src/network/ssl/qsslcertificate_openssl.cpp
+++ b/src/network/ssl/qsslcertificate_openssl.cpp
@@ -46,6 +46,7 @@
 
 #include <QtCore/qendian.h>
 #include <QtCore/qmutex.h>
+#include <QtCore/qscopeguard.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -318,6 +319,34 @@ QSslKey QSslCertificate::publicKey() const
     return key;
 }
 
+#if QT_CONFIG(wolfssl)
+static void wolfssl_extinternal_free(X509V3_EXT_METHOD  *meth, void *internal)
+{
+
+    if (!meth || !internal) return;
+
+    switch(meth->ext_nid) {
+        case (NID_basic_constraints):
+            BASIC_CONSTRAINTS_free((BASIC_CONSTRAINTS*)internal);
+            break;
+        case (NID_subject_key_identifier):
+            ASN1_STRING_free((ASN1_STRING*)internal);
+            break;
+        case (NID_authority_key_identifier):
+            AUTHORITY_KEYID_free((AUTHORITY_KEYID*)internal);
+            break;
+        case (NID_key_usage):
+            ASN1_STRING_free((ASN1_STRING*)internal);
+            break;
+        case (NID_info_access):
+            AUTHORITY_INFO_ACCESS_pop_free((AUTHORITY_INFO_ACCESS*)internal, NULL);
+            break;
+        default:
+           qCWarning(lcSsl, "No method to free an unknown extension, a potential memory leak");
+    }
+
+}
+#endif
 /*
  * Convert unknown extensions to a QVariant.
  */
@@ -337,11 +366,31 @@ static QVariant x509UnknownExtensionToValue(X509_EXTENSION *ext)
 
     //const unsigned char *data = ext->value->data;
     void *ext_internal = q_X509V3_EXT_d2i(ext);
+    if (!ext_internal)
+        return {};
+
+    const auto extCleaner = qScopeGuard([meth, ext_internal]{
+        Q_ASSERT(ext_internal && meth);
+    #if !QT_CONFIG(wolfssl)
+        if (meth->it)
+            q_ASN1_item_free(static_cast<ASN1_VALUE *>(ext_internal), ASN1_ITEM_ptr(meth->it));
+        else if (meth->ext_free)
+            meth->ext_free(ext_internal);
+        else
+            qCWarning(lcSsl, "No method to free an unknown extension, a potential memory leak?");
+    #else
+        wolfssl_extinternal_free(meth, ext_internal);
+    #endif
+    });
 
     // If this extension can be converted
-    if (meth->i2v && ext_internal) {
+    if (meth->i2v) {
         STACK_OF(CONF_VALUE) *val = meth->i2v(meth, ext_internal, nullptr);
-
+        const auto stackCleaner = qScopeGuard([val]{
+            if (val)
+                q_OPENSSL_sk_pop_free((OPENSSL_STACK *)val, (void(*)(void*))q_X509V3_conf_free);
+        });
+
         QVariantMap map;
         QVariantList list;
         bool isMap = false;
@@ -362,11 +411,13 @@ static QVariant x509UnknownExtensionToValue(X509_EXTENSION *ext)
             return map;
         else
             return list;
-    } else if (meth->i2s && ext_internal) {
+    } else if (meth->i2s) {
         //qCDebug(lcSsl) << meth->i2s(meth, ext_internal);
-        QVariant result(QString::fromUtf8(meth->i2s(meth, ext_internal)));
+        const char *hexString = meth->i2s(meth, ext_internal);
+        QVariant result(hexString ? QString::fromUtf8(hexString) : QString{});
+        q_OPENSSL_free((void *)hexString);
         return result;
-    } else if (meth->i2r && ext_internal) {
+    } else if (meth->i2r) {
         QByteArray result;
 
         BIO *bio = q_BIO_new(q_BIO_s_mem());
@@ -396,6 +447,34 @@ static QVariant x509ExtensionToValue(X509_EXTENSION *ext)
     ASN1_OBJECT *obj = q_X509_EXTENSION_get_object(ext);
     int nid = q_OBJ_obj2nid(obj);
 
+    // We cast away the const-ness here because some versions of openssl
+    // don't use const for the parameters in the functions pointers stored
+    // in the object.
+    X509V3_EXT_METHOD *meth = const_cast<X509V3_EXT_METHOD *>(q_X509V3_EXT_get(ext));
+
+    void *ext_internal = nullptr;
+    const auto extCleaner = qScopeGuard([meth, ext_internal]{
+        if (!meth || !ext_internal)
+            return;
+
+    #if !QT_CONFIG(wolfssl)
+        if (meth->it)
+            q_ASN1_item_free(static_cast<ASN1_VALUE *>(ext_internal), ASN1_ITEM_ptr(meth->it));
+        else if (meth->ext_free)
+            meth->ext_free(ext_internal);
+        else
+            qCWarning(lcSsl, "No method to free an unknown extension, a potential memory leak?");
+    #else
+        wolfssl_extinternal_free(meth, ext_internal);
+    #endif
+    });
+
+    const char * hexString = nullptr;
+    const auto hexStringCleaner = qScopeGuard([&hexString](){
+        if (hexString)
+            q_OPENSSL_free((void*)hexString);
+    });
+
     switch (nid) {
     case NID_basic_constraints:
         {
@@ -434,21 +513,19 @@ static QVariant x509ExtensionToValue(X509_EXTENSION *ext)
                     qCWarning(lcSsl) << "Strange location type" << name->type;
                 }
             }
-
-            q_OPENSSL_sk_pop_free((OPENSSL_STACK*)info, reinterpret_cast<void(*)(void *)>(q_OPENSSL_sk_free));
+
+            q_AUTHORITY_INFO_ACCESS_free(info);
             return result;
         }
         break;
     case NID_subject_key_identifier:
         {
-            void *ext_internal = q_X509V3_EXT_d2i(ext);
-
-            // we cast away the const-ness here because some versions of openssl
-            // don't use const for the parameters in the functions pointers stored
-            // in the object.
-            X509V3_EXT_METHOD *meth = const_cast<X509V3_EXT_METHOD *>(q_X509V3_EXT_get(ext));
-
-            return QVariant(QString::fromUtf8(meth->i2s(meth, ext_internal)));
+            ext_internal = q_X509V3_EXT_d2i(ext);
+            if (!ext_internal)
+                return {};
+
+            hexString = meth->i2s(meth, ext_internal);
+            return QVariant(QString::fromUtf8(hexString));
         }
         break;
     case NID_authority_key_identifier:
@@ -661,7 +738,7 @@ static QMultiMap<QByteArray, QString> _q_mapFromX509Name(X509_NAME *name)
         unsigned char *data = nullptr;
         int size = q_ASN1_STRING_to_UTF8(&data, q_X509_NAME_ENTRY_get_data(e));
         info.insert(name, QString::fromUtf8((char*)data, size));
-#if QT_CONFIG(opensslv11)
+#if QT_CONFIG(opensslv11) || QT_CONFIG(wolfssl)
         q_CRYPTO_free(data, nullptr, 0);
 #else
         q_CRYPTO_free(data);
diff --git a/src/network/ssl/qsslcontext_openssl.cpp b/src/network/ssl/qsslcontext_openssl.cpp
index c9f202f573..d2ea10a07e 100644
--- a/src/network/ssl/qsslcontext_openssl.cpp
+++ b/src/network/ssl/qsslcontext_openssl.cpp
@@ -456,7 +456,11 @@ init_context:
 
     // Enable bug workarounds.
     long options = QSslSocketBackendPrivate::setupOpenSslOptions(configuration.protocol(), configuration.d->sslOptions);
+#if !QT_CONFIG(wolfssl)
     q_SSL_CTX_set_options(sslContext->ctx, options);
+#else
+    q_SSL_CTX_ctrl(sslContext->ctx, SSL_CTRL_OPTIONS, options, nullptr);
+#endif
 
     // Tell OpenSSL to release memory early
     // http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html
diff --git a/src/network/ssl/qsslcontext_openssl_p.h b/src/network/ssl/qsslcontext_openssl_p.h
index 70cb97aad8..f66008b997 100644
--- a/src/network/ssl/qsslcontext_openssl_p.h
+++ b/src/network/ssl/qsslcontext_openssl_p.h
@@ -54,6 +54,9 @@
 //
 
 #include <QtNetwork/private/qtnetworkglobal_p.h>
+#if QT_CONFIG(wolfssl)
+#include "wolfssl/options.h"
+#endif
 #include <QtCore/qvariant.h>
 #include <QtNetwork/qsslcertificate.h>
 #include <QtNetwork/qsslconfiguration.h>
diff --git a/src/network/ssl/qsslkey_p.cpp b/src/network/ssl/qsslkey_p.cpp
index b0d6c729f9..ba5275b483 100644
--- a/src/network/ssl/qsslkey_p.cpp
+++ b/src/network/ssl/qsslkey_p.cpp
@@ -189,7 +189,7 @@ QByteArray QSslKeyPrivate::pemFromDer(const QByteArray &der, const QMap<QByteArr
     if (isEncryptedPkcs8(der)) {
         pem.prepend(pkcs8Header(true) + '\n' + extra);
         pem.append(pkcs8Footer(true) + '\n');
-#if !QT_CONFIG(openssl)
+#if !QT_CONFIG(openssl) && !QT_CONFIG(wolfssl)
     } else if (isPkcs8) {
         pem.prepend(pkcs8Header(false) + '\n' + extra);
         pem.append(pkcs8Footer(false) + '\n');
diff --git a/src/network/ssl/qsslkey_p.h b/src/network/ssl/qsslkey_p.h
index dd1a31b0e5..d2dae9fc2b 100644
--- a/src/network/ssl/qsslkey_p.h
+++ b/src/network/ssl/qsslkey_p.h
@@ -93,7 +93,7 @@ public:
     Qt::HANDLE handle() const;
 
     bool isEncryptedPkcs8(const QByteArray &der) const;
-#if !QT_CONFIG(openssl)
+#if !QT_CONFIG(openssl) && !QT_CONFIG(wolfssl)
     QByteArray decryptPkcs8(const QByteArray &encrypted, const QByteArray &passPhrase);
     bool isPkcs8 = false;
 #endif
diff --git a/src/network/ssl/qsslsocket_openssl.cpp b/src/network/ssl/qsslsocket_openssl.cpp
index 277037e59c..e3d792a7ae 100644
--- a/src/network/ssl/qsslsocket_openssl.cpp
+++ b/src/network/ssl/qsslsocket_openssl.cpp
@@ -197,6 +197,7 @@ static unsigned int q_ssl_psk_server_callback(SSL *ssl,
 }
 
 #ifdef TLS1_3_VERSION
+#if OPENSSL_VERSION_NUMBER >= 0x10101006L
 static unsigned int q_ssl_psk_restore_client(SSL *ssl,
                                              const char *hint,
                                              char *identity, unsigned int max_identity_len,
@@ -238,7 +239,7 @@ static int q_ssl_psk_use_session_callback(SSL *ssl, const EVP_MD *md, const unsi
 
     return 1; // need to return 1 or else "the connection setup fails."
 }
-
+#endif // OPENSSL_VERSION_NUMBER >= 0x10101006L
 int q_ssl_sess_set_new_cb(SSL *ssl, SSL_SESSION *session)
 {
     if (!ssl) {
@@ -1211,9 +1212,38 @@ void QSslSocketBackendPrivate::transmit()
     } while (ssl && transmitting);
 }
 
+#if QT_CONFIG(wolfssl)
+static int GetX509Error(int e)
+{
+    switch (e) {
+        case ASN_BEFORE_DATE_E:
+            return X509_V_ERR_CERT_NOT_YET_VALID;
+        case ASN_AFTER_DATE_E:
+            return X509_V_ERR_CERT_HAS_EXPIRED;
+        case ASN_NO_SIGNER_E:
+            return X509_V_ERR_INVALID_CA;
+        case ASN_SELF_SIGNED_E:
+            return X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
+        case ASN_PATHLEN_INV_E:
+        case ASN_PATHLEN_SIZE_E:
+            return X509_V_ERR_PATH_LENGTH_EXCEEDED;
+        case ASN_SIG_OID_E:
+        case ASN_SIG_CONFIRM_E:
+        case ASN_SIG_HASH_E:
+        case ASN_SIG_KEY_E:
+            return X509_V_ERR_CERT_SIGNATURE_FAILURE;
+        default:
+            return e;
+    }
+}
+#endif
+
 QSslError _q_OpenSSL_to_QSslError(int errorCode, const QSslCertificate &cert)
 {
     QSslError error;
+#if QT_CONFIG(wolfssl)
+    errorCode = GetX509Error(errorCode);
+#endif
     switch (errorCode) {
     case X509_V_OK:
         // X509_V_OK is also reported if the peer had no certificate.
diff --git a/src/network/ssl/qsslsocket_openssl_p.h b/src/network/ssl/qsslsocket_openssl_p.h
index 67f267aec1..a33e649a01 100644
--- a/src/network/ssl/qsslsocket_openssl_p.h
+++ b/src/network/ssl/qsslsocket_openssl_p.h
@@ -82,6 +82,11 @@
 #endif
 #endif // Q_OS_WIN
 
+#if QT_CONFIG(wolfssl)
+#include "wolfssl/options.h"
+#include "wolfssl/ssl.h"
+#endif
+
 #include <openssl/asn1.h>
 #include <openssl/bio.h>
 #include <openssl/bn.h>
diff --git a/src/network/ssl/qsslsocket_openssl_symbols.cpp b/src/network/ssl/qsslsocket_openssl_symbols.cpp
index ed80fc14bd..6ced838b8a 100644
--- a/src/network/ssl/qsslsocket_openssl_symbols.cpp
+++ b/src/network/ssl/qsslsocket_openssl_symbols.cpp
@@ -178,6 +178,10 @@ DEFINEFUNC(const SSL_METHOD *, TLS_server_method, DUMMYARG, DUMMYARG, return nul
 DEFINEFUNC(void, X509_up_ref, X509 *a, a, return, DUMMYARG)
 DEFINEFUNC(ASN1_TIME *, X509_getm_notBefore, X509 *a, a, return nullptr, return)
 DEFINEFUNC(ASN1_TIME *, X509_getm_notAfter, X509 *a, a, return nullptr, return)
+#if !QT_CONFIG(wolfssl)
+DEFINEFUNC2(void, ASN1_item_free, ASN1_VALUE *val, val, const ASN1_ITEM *it, it, return, return)
+#endif
+DEFINEFUNC(void, X509V3_conf_free, CONF_VALUE *val, val, return, return)
 DEFINEFUNC(long, X509_get_version, X509 *a, a, return -1, return)
 DEFINEFUNC(EVP_PKEY *, X509_get_pubkey, X509 *a, a, return nullptr, return)
 DEFINEFUNC2(void, X509_STORE_set_verify_cb, X509_STORE *a, a, X509_STORE_CTX_verify_cb verify_cb, verify_cb, return, DUMMYARG)
@@ -187,7 +191,6 @@ DEFINEFUNC(STACK_OF(X509) *, X509_STORE_CTX_get0_chain, X509_STORE_CTX *a, a, re
 DEFINEFUNC3(void, CRYPTO_free, void *str, str, const char *file, file, int line, line, return, DUMMYARG)
 DEFINEFUNC(long, OpenSSL_version_num, void, DUMMYARG, return 0, return)
 DEFINEFUNC(const char *, OpenSSL_version, int a, a, return nullptr, return)
-DEFINEFUNC(unsigned long, SSL_SESSION_get_ticket_lifetime_hint, const SSL_SESSION *session, session, return 0, return)
 DEFINEFUNC4(void, DH_get0_pqg, const DH *dh, dh, const BIGNUM **p, p, const BIGNUM **q, q, const BIGNUM **g, g, return, DUMMYARG)
 DEFINEFUNC(int, DH_bits, DH *dh, dh, return 0, return)
 
@@ -234,6 +237,7 @@ DEFINEFUNC6(int, OCSP_basic_sign, OCSP_BASICRESP *br, br, X509 *signer, signer,
             const EVP_MD *dg, dg, STACK_OF(X509) *cs, cs, unsigned long flags, flags, return 0, return)
 #endif // ocsp
 
+DEFINEFUNC(void, AUTHORITY_INFO_ACCESS_free, AUTHORITY_INFO_ACCESS *p, p, return, return)
 DEFINEFUNC2(void, BIO_set_data, BIO *a, a, void *ptr, ptr, return, DUMMYARG)
 DEFINEFUNC(void *, BIO_get_data, BIO *a, a, return nullptr, return)
 DEFINEFUNC2(void, BIO_set_init, BIO *a, a, int init, init, return, DUMMYARG)
@@ -844,6 +848,7 @@ bool q_resolveOpenSslSymbols()
     RESOLVEFUNC(OPENSSL_init_crypto)
     RESOLVEFUNC(ASN1_STRING_get0_data)
     RESOLVEFUNC(EVP_CIPHER_CTX_reset)
+    RESOLVEFUNC(AUTHORITY_INFO_ACCESS_free)
     RESOLVEFUNC(EVP_PKEY_up_ref)
     RESOLVEFUNC(EVP_PKEY_CTX_new)
     RESOLVEFUNC(EVP_PKEY_param_check)
@@ -880,6 +885,10 @@ bool q_resolveOpenSslSymbols()
     RESOLVEFUNC(X509_STORE_CTX_get0_chain)
     RESOLVEFUNC(X509_getm_notBefore)
     RESOLVEFUNC(X509_getm_notAfter)
+    #if !QT_CONFIG(wolfssl)
+    RESOLVEFUNC(ASN1_item_free)
+    #endif
+    RESOLVEFUNC(X509V3_conf_free)
     RESOLVEFUNC(X509_get_version)
     RESOLVEFUNC(X509_get_pubkey)
     RESOLVEFUNC(X509_STORE_set_verify_cb)
diff --git a/src/network/ssl/qsslsocket_openssl_symbols_p.h b/src/network/ssl/qsslsocket_openssl_symbols_p.h
index c46afcf53e..63d59f083c 100644
--- a/src/network/ssl/qsslsocket_openssl_symbols_p.h
+++ b/src/network/ssl/qsslsocket_openssl_symbols_p.h
@@ -69,6 +69,11 @@
 //
 
 #include <QtNetwork/private/qtnetworkglobal_p.h>
+#if QT_CONFIG(wolfssl)
+#include "wolfssl/options.h"
+#include "wolfssl/ssl.h"
+#endif
+
 #include "qsslsocket_openssl_p.h"
 #include <QtCore/qglobal.h>
 
@@ -230,6 +235,7 @@ const unsigned char * q_ASN1_STRING_get0_data(const ASN1_STRING *x);
 Q_AUTOTEST_EXPORT BIO *q_BIO_new(const BIO_METHOD *a);
 Q_AUTOTEST_EXPORT const BIO_METHOD *q_BIO_s_mem();
 
+void q_AUTHORITY_INFO_ACCESS_free(AUTHORITY_INFO_ACCESS *a);
 int q_DSA_bits(DSA *a);
 int q_EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c);
 Q_AUTOTEST_EXPORT int q_EVP_PKEY_up_ref(EVP_PKEY *a);
@@ -255,6 +261,10 @@ const SSL_METHOD *q_TLS_client_method();
 const SSL_METHOD *q_TLS_server_method();
 ASN1_TIME *q_X509_getm_notBefore(X509 *a);
 ASN1_TIME *q_X509_getm_notAfter(X509 *a);
+#if !QT_CONFIG(wolfssl)
+void q_ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it);
+#endif
+void q_X509V3_conf_free(CONF_VALUE *val);
 
 Q_AUTOTEST_EXPORT void q_X509_up_ref(X509 *a);
 long q_X509_get_version(X509 *a);
@@ -279,12 +289,11 @@ int q_DH_bits(DH *dh);
                                                                     | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL)
 
 int q_OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);
-void q_CRYPTO_free(void *str, const char *file, int line);
 
 long q_OpenSSL_version_num();
 const char *q_OpenSSL_version(int type);
 
-unsigned long q_SSL_SESSION_get_ticket_lifetime_hint(const SSL_SESSION *session);
+#define q_SSL_SESSION_get_ticket_lifetime_hint(s) wolfSSL_SESSION_get_timeout(s)
 unsigned long q_SSL_set_options(SSL *s, unsigned long op);
 
 #ifdef TLS1_3_VERSION
@@ -747,7 +756,8 @@ int q_OCSP_id_cmp(OCSP_CERTID *a, OCSP_CERTID *b);
 
 void *q_CRYPTO_malloc(size_t num, const char *file, int line);
 #define q_OPENSSL_malloc(num) q_CRYPTO_malloc(num, "", 0)
-
+void q_CRYPTO_free(void *str, const char *file, int line);
+# define q_OPENSSL_free(addr) q_CRYPTO_free(addr, "", 0)
 int q_SSL_CTX_get_security_level(const SSL_CTX *ctx);
 void q_SSL_CTX_set_security_level(SSL_CTX *ctx, int level);
 
diff --git a/src/network/ssl/ssl.pri b/src/network/ssl/ssl.pri
index 230c45c26f..132b0e356d 100644
--- a/src/network/ssl/ssl.pri
+++ b/src/network/ssl/ssl.pri
@@ -13,7 +13,9 @@ SOURCES += ssl/qasn1element.cpp \
            ssl/qsslcertificate.cpp \
            ssl/qsslcertificateextension.cpp
 
-!qtConfig(openssl): SOURCES += ssl/qsslcertificate_qt.cpp
+!qtConfig(openssl) {
+    !qtConfig(wolfssl): SOURCES += ssl/qsslcertificate_qt.cpp
+}
 
 qtConfig(ssl) {
     HEADERS += ssl/qsslconfiguration.h \
@@ -127,6 +129,34 @@ qtConfig(ssl) {
             SOURCES += ssl/qwindowscarootfetcher.cpp
         }
     }
+    qtConfig(wolfssl) {
+        HEADERS += ssl/qsslcontext_openssl_p.h \
+                   ssl/qsslsocket_openssl_p.h \
+                   ssl/qsslsocket_openssl_symbols_p.h
+        SOURCES += ssl/qsslsocket_openssl_symbols.cpp \
+                   ssl/qssldiffiehellmanparameters_openssl.cpp \
+                   ssl/qsslcertificate_openssl.cpp \
+                   ssl/qsslellipticcurve_openssl.cpp \
+                   ssl/qsslkey_openssl.cpp \
+                   ssl/qsslsocket_openssl.cpp \
+                   ssl/qsslcontext_openssl.cpp \
+
+        QMAKE_CXXFLAGS += -DOPENSSL_API_COMPAT=0x10100000L -DOPENSSL_NO_NEXTPROTONEG
+
+        darwin:SOURCES += ssl/qsslsocket_mac_shared.cpp
+
+        android:!android-embedded: SOURCES += ssl/qsslsocket_openssl_android.cpp
+
+        qtConfig(wolfssl-linked): \
+            QMAKE_USE_FOR_PRIVATE += wolfssl
+        else: \
+            QMAKE_USE_FOR_PRIVATE += wolfssl/nolink
+        win32 {
+            LIBS_PRIVATE += -lcrypt32
+            HEADERS += ssl/qwindowscarootfetcher_p.h
+            SOURCES += ssl/qwindowscarootfetcher.cpp
+        }
+    }
 }
 
 HEADERS += ssl/qpassworddigestor.h
diff --git a/tests/auto/network/ssl/qsslcertificate/tst_qsslcertificate.cpp b/tests/auto/network/ssl/qsslcertificate/tst_qsslcertificate.cpp
index e89b7f5a44..c9a9e851e8 100644
--- a/tests/auto/network/ssl/qsslcertificate/tst_qsslcertificate.cpp
+++ b/tests/auto/network/ssl/qsslcertificate/tst_qsslcertificate.cpp
@@ -37,6 +37,10 @@
 #include <openssl/obj_mac.h>
 #endif
 
+#ifndef QT_NO_WOLFSSL
+#include <wolfcrypt/logging.h>
+#endif
+
 class tst_QSslCertificate : public QObject
 {
     Q_OBJECT
@@ -1029,7 +1033,9 @@ void tst_QSslCertificate::multipleCommonNames()
     QList<QSslCertificate> certList =
         QSslCertificate::fromPath(testDataDir + "more-certificates/test-cn-two-cns-cert.pem", QSsl::Pem, QSslCertificate::PatternSyntax::FixedString);
     QVERIFY(certList.count() > 0);
-
+#ifndef QT_NO_WOLFSSL
+    QSKIP("wolfSSL does not support multiple common names");
+#endif
     QStringList commonNames = certList[0].subjectInfo(QSslCertificate::CommonName);
     QVERIFY(commonNames.contains(QString("www.example.com")));
     QVERIFY(commonNames.contains(QString("www2.example.com")));
diff --git a/tests/auto/network/ssl/qsslkey/tst_qsslkey.cpp b/tests/auto/network/ssl/qsslkey/tst_qsslkey.cpp
index 8ff6d35ba2..5552c6cd71 100644
--- a/tests/auto/network/ssl/qsslkey/tst_qsslkey.cpp
+++ b/tests/auto/network/ssl/qsslkey/tst_qsslkey.cpp
@@ -253,6 +253,18 @@ void tst_QSslKey::constructor()
     QByteArray passphrase;
     if (QByteArray(QTest::currentDataTag()).contains("-pkcs8-"))
         passphrase = QByteArray("1234");
+    #ifndef QT_NO_WOLFSSL
+    if (QByteArray(QTest::currentDataTag()).contains("rc2") || QByteArray(QTest::currentDataTag()).contains("RC2"))
+        QSKIP("wolfSSL does not support the rc2 algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("2des") || QByteArray(QTest::currentDataTag()).contains("2DES"))
+        QSKIP("wolfSSL does not support the 2des algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("rc4-40") || QByteArray(QTest::currentDataTag()).contains("RC4"))
+        QSKIP("wolfSSL does not support the 40 bit key RC4 algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("dsa-") && QByteArray(QTest::currentDataTag()).contains("pkcs8"))
+        QSKIP("wolfSSL does not support the dsa key format with pkcs8.");
+    if (QByteArray(QTest::currentDataTag()).contains("dh-"))
+        QSKIP("wolfSSL does not support the dh private key format.");
+    #endif
     QSslKey key(encoded, algorithm, format, type, passphrase);
     QVERIFY(!key.isNull());
 }
@@ -285,6 +297,18 @@ void tst_QSslKey::constructorHandle()
     QByteArray passphrase;
     if (QByteArray(QTest::currentDataTag()).contains("-pkcs8-"))
         passphrase = "1234";
+    #ifndef QT_NO_WOLFSSL
+    if (QByteArray(QTest::currentDataTag()).contains("rc2") || QByteArray(QTest::currentDataTag()).contains("RC2"))
+        QSKIP("wolfSSL does not support the rc2 algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("2des") || QByteArray(QTest::currentDataTag()).contains("2DES"))
+        QSKIP("wolfSSL does not support the 2des algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("rc4-40") || QByteArray(QTest::currentDataTag()).contains("RC4"))
+        QSKIP("wolfSSL does not support the 40 bit key RC4 algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("dsa-"))
+        QSKIP("wolfSSL does not support the dsa key format with pkcs8.");
+    if (QByteArray(QTest::currentDataTag()).contains("dh-"))
+        QSKIP("wolfSSL does not support the dh private key format.");
+    #endif
 
     BIO* bio = q_BIO_new(q_BIO_s_mem());
     q_BIO_write(bio, pem.constData(), pem.length());
@@ -392,6 +416,18 @@ void tst_QSslKey::length()
     QByteArray passphrase;
     if (QByteArray(QTest::currentDataTag()).contains("-pkcs8-"))
         passphrase = QByteArray("1234");
+    #ifndef QT_NO_WOLFSSL
+    if (QByteArray(QTest::currentDataTag()).contains("rc2") || QByteArray(QTest::currentDataTag()).contains("RC2"))
+        QSKIP("wolfSSL does not support the rc2 algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("2des") || QByteArray(QTest::currentDataTag()).contains("2DES"))
+        QSKIP("wolfSSL does not support the 2des algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("rc4-40") || QByteArray(QTest::currentDataTag()).contains("RC4"))
+        QSKIP("wolfSSL does not support the 40 bit key RC4 algorithm.");
+    if (QByteArray(QTest::currentDataTag()).contains("dsa-") && QByteArray(QTest::currentDataTag()).contains("pkcs8"))
+        QSKIP("wolfSSL does not support the dsa key format with pkcs8.");
+    if (QByteArray(QTest::currentDataTag()).contains("dh-"))
+        QSKIP("wolfSSL does not support the dh private key format.");
+    #endif
     QSslKey key(encoded, algorithm, format, type, passphrase);
     QVERIFY(!key.isNull());
     QCOMPARE(key.length(), length);
@@ -423,6 +459,10 @@ void tst_QSslKey::toPemOrDer()
         QSKIP("PKCS#8 RSA keys are changed into a different format in the generic back-end, meaning the comparison fails.");
 #endif // openssl
 
+    #ifndef QT_NO_WOLFSSL
+    if (QByteArray(QTest::currentDataTag()).contains("dh-"))
+        QSKIP("wolfSSL does not support the dh private key format.");
+    #endif
     QByteArray encoded = readFile(absFilePath);
     QSslKey key(encoded, algorithm, format, type);
     QVERIFY(!key.isNull());
@@ -470,6 +510,13 @@ void tst_QSslKey::toEncryptedPemOrDer()
     QFETCH(QSsl::EncodingFormat, format);
     QFETCH(QString, password);
 
+    #ifndef QT_NO_WOLFSSL
+    if (QByteArray(QTest::currentDataTag()).contains("dsa-") && QByteArray(QTest::currentDataTag()).contains("pkcs8"))
+        QSKIP("wolfSSL does not support the dsa key format with pkcs8.");
+    if (QByteArray(QTest::currentDataTag()).contains("dh-"))
+        QSKIP("wolfSSL does not support the dh private key format.");
+    #endif
+
     QByteArray plain = readFile(absFilePath);
     QSslKey key(plain, algorithm, format, type);
     QVERIFY(!key.isNull());
@@ -519,7 +566,9 @@ void tst_QSslKey::passphraseChecks_data()
 
     QTest::newRow("DES") << QString(testDataDir + "rsa-with-passphrase-des.pem") << pass;
     QTest::newRow("3DES") << QString(testDataDir + "rsa-with-passphrase-3des.pem") << pass;
+#if defined(QT_NO_WOLFSSL)
     QTest::newRow("RC2") << QString(testDataDir + "rsa-with-passphrase-rc2.pem") << pass;
+#endif
 #if (!defined(QT_NO_OPENSSL) && !defined(OPENSSL_NO_AES)) || (defined(QT_NO_OPENSSL) && QT_CONFIG(ssl))
     QTest::newRow("AES128") << QString(testDataDir + "rsa-with-passphrase-aes128.pem") << aesPass;
     QTest::newRow("AES192") << QString(testDataDir + "rsa-with-passphrase-aes192.pem") << aesPass;
@@ -667,7 +716,7 @@ void tst_QSslKey::encrypt_data()
         << QByteArray(8, 'a')
         << QByteArray::fromHex("F2A5A87763C54A72A3224103D90CDB03")
         << iv;
-
+#if defined(QT_NO_WOLFSSL)
     QTest::newRow("RC2-40-CBC, length 0")
         << QSslKeyPrivate::Rc2Cbc << QByteArray("01234")
         << QByteArray()
@@ -700,7 +749,7 @@ void tst_QSslKey::encrypt_data()
         << QByteArray(8, 'a')
         << QByteArray::fromHex("5AEC1A5B295660B02613454232F7DECE")
         << iv;
-
+#endif // QT_NO_WOLFSSL
 #if (!defined(QT_NO_OPENSSL) && !defined(OPENSSL_NO_AES)) || (defined(QT_NO_OPENSSL) && QT_CONFIG(ssl))
     // AES needs a longer IV
     iv = QByteArray("abcdefghijklmnop");
@@ -748,10 +797,12 @@ void tst_QSslKey::encrypt()
     QFETCH(QByteArray, iv);
 
 #if defined(Q_OS_WINRT) || QT_CONFIG(schannel)
+#if defined(QT_NO_WOLFSSL)
     QEXPECT_FAIL("RC2-40-CBC, length 0", "WinRT/Schannel treats RC2 as 128-bit", Abort);
     QEXPECT_FAIL("RC2-40-CBC, length 8", "WinRT/Schannel treats RC2 as 128-bit", Abort);
     QEXPECT_FAIL("RC2-64-CBC, length 0", "WinRT/Schannel treats RC2 as 128-bit", Abort);
     QEXPECT_FAIL("RC2-64-CBC, length 8", "WinRT/Schannel treats RC2 as 128-bit", Abort);
+#endif
 #endif
     QByteArray encrypted = QSslKeyPrivate::encrypt(cipher, plainText, key, iv);
     QCOMPARE(encrypted, cipherText);
diff --git a/tests/auto/network/ssl/qsslsocket/tst_qsslsocket.cpp b/tests/auto/network/ssl/qsslsocket/tst_qsslsocket.cpp
index 5903eb6488..34eb42041f 100644
--- a/tests/auto/network/ssl/qsslsocket/tst_qsslsocket.cpp
+++ b/tests/auto/network/ssl/qsslsocket/tst_qsslsocket.cpp
@@ -3350,7 +3350,11 @@ void tst_QSslSocket::verifyClientCertificate_data()
     QTest::newRow("ValidServerCert:AutoVerifyPeer") << QSslSocket::AutoVerifyPeer << serverCerts << serverKey << true;
     QTest::newRow("ValidServerCert:QueryPeer") << QSslSocket::QueryPeer << serverCerts << serverKey << true;
     QTest::newRow("ValidServerCert:VerifyNone") << QSslSocket::VerifyNone << serverCerts << serverKey << true;
+    #if defined(QT_NO_WOLFSSL)
     QTest::newRow("ValidServerCert:VerifyPeer") << QSslSocket::VerifyPeer << serverCerts << serverKey << false;
+    #else
+    QWARN("wolfSSL does not currently support parsing Netscape Cert Type Extensions.");
+    #endif
 
     // valid certificate, correct usage (client certificate)
     QList<QSslCertificate> validCerts = QSslCertificate::fromPath(testDataDir + "certs/bogus-client.crt");
